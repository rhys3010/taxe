\chapter{Background \& Objectives}

\section{Background}
The aim of this project was to create a platform that serves as an intermediary between local taxi companies and their customers. The platform supports three types of users: Company Admin, Driver and Customer. It consists of two user-facing applications: An android app - intended to be usable by Drivers and Customers, and a mobile-friendly web application - intended to be usable by Company Admins. Both applications are served by a single REST API.

Currently, it is intended that a single instance of the platform is used by many taxi companies, each with their own Company Admins and Drivers. The companies would then use the platform as a service in order to support their internal booking mechanisms. However, it can be adapted to be used by a single Company as their sole booking management mechanism. This makes the platform very flexible, allowing for varying use cases.

The primary motivation for this project was to streamline the process of making taxi bookings in small, local areas. With the hope that a fully mobile, digital solution would lead to a better experience for both the companies and their customers. For example, being able to view a history of all bookings could be extremely helpful for cases of lost property, criminal damage, etc. In addition to this, by viewing the live status of their booking, and communicating with their driver via notes, customers can make sure they are present for their booking at the correct time, hopefully resulting in fewer wasted Taxis.

\subsection{Background Research}
In order to successfully execute the project, research had to be done into various aspects of the app's development. This includes methodology, technologies, and deployment options.

\subsubsection{Methodology}\label{methodology_research_ref}
Software Development Methodology is a key part of any large project. The effect of the methodology on the product, along with a project's ability to adapt to the methodology should always be considered when making a selection. With this in mind, several options were researched for the project.

The first methodology researched was the Waterfall Model, or 'SDLC'~\cite{sdlc_ref}. Having already worked on a project using the Waterfall Model, there was less of a focus on researching the methodology but rather to consider its applicability in this project. As the Waterfall Model is a plan-driven approach it would require a lot of upfront documentation and decision making with regards to requirements, thus potentially making it rather inflexible. Given that this project also involved a significant learning curve with regards to the technologies used, it would perhaps be tricky to accurately gauge the ability to implement various functionalities early on.

The next methodology researched was Feature Driven Development, or 'FDD'~\cite{fdd_practical_guide_ref}. FDD is an agile methodology created by Jeff Luca, it is an iterative approach with an emphasis on the timely and successful delivery of features. It is broken down into 5 key processes: developing an overall model, building the feature list, planning by feature, designing by feature, and building by feature. It is clear from these processes that the project's development would be done on a 'per-feature' basis, comparable to stories in other agile methodologies. At first impressions, this methodology seemed much more appropriate for the project than a plan based approach.

Extreme Programming or 'XP'~\cite{xp_explained_ref, xp_agilealliance_ref}, was the final methodology to be researched. It was one of the recommended methodologies provided for the project. XP is described as being ideal in projects with dynamically changing requirements, risks from fixed time projects using new technology, and when using technologies that allow for automated tests~\cite{xp_agilealliance_ref}. The methodology is often identified by its values, which give a great indication to the mission of XP. Reading literature written by one of XP's creators provided a great insight into the application of XP and its key advantages over other approaches.

\subsubsection{Technologies}
Having only experienced Android app development with a local, offline backend; it was essential to the project's success that research was done to explore the tools and technologies available to support a networked mobile app. This research was required for each aspect of the project, including its deployment.

The first and arguably most significant area to research was the API that would support the app(s). It was clear from very early on that there would likely be at least two apps within the platform to consume the API (web app and mobile app).  Therefore, an API would need to be developed and a language/framework had to be selected to develop such an API. The researched options were: ASP.NET~\cite{dotnet_documentation_ref}, Rails 5~\cite{rails_documentation_ref}, Node.js \& Express.js~\cite{nodejs_documentation_ref, expressjs_documentation_ref} and Flask (Flask-RESTful)~\cite{flask_documentation_ref}. All of the researched options had fairly similar learning curves (due to the technology they are built on and past experiences), each option was also perfectly fit for purpose to create a REST API  to serve a mobile application.

The next technology to research was the database management system (DBMS) that would be used by the REST API for data persistence. The selected DBMS would ideally be able to interface easily with the framework used to create the API itself. The options researched were: PostgreSQL~\cite{postgres_documentation_ref}, MySQL~\cite{mysql_documentation_ref}, and MongoDB~\cite{mongodb_documentation_ref}. The first two options were both traditional relational database management systems, whereas the final option is a NoSQL document-oriented system.

In order to successfully consume the REST API within the Android application, a HTTP Client library had to be chosen. During this selection, two complementary technologies were researched, Retrofit~\cite{retrofit_documentation_ref} and rxJava~\cite{rxjava_documentation_ref}. Retrofit is a HTTP Client library for Java and Android that is primarily used to consume REST APIs, rxJava is an asynchronous programming library with observable streams. This allows requests to be made to the REST API from the mobile application and the responses can be stored in a life-cycle aware Observable object, thus fully supporting asynchronous programming.

It became apparent that a relatively small web app would need to be created as part of the platform to support the Company Administrator's role. Therefore, a front-end web framework to consume the API had to be chosen. The frameworks that were looked into were: Angular~\cite{angular_documentation_ref} and React~\cite{react_documentation_ref}. Although Vue.js~\cite{vue_documentation_ref} was initially considered, it became apparent that React and Angular were the two most prominent options and would be the most beneficial technologies to learn.

Due to previous experience, it was already decided that Android Studio would be the chosen IDE used to develop the Android application. However, there was still a decision to be made about developing the API and Web Application. The standard code editor 'Atom' had been used for previous web projects. However, upon further research JetBrains's 'WebStorm' IDE was discovered. Therefore research was done into both solutions in order to select the most appropriate.

Lastly, project management, deployment, and development tools had to be researched. In terms of project management, it was already decided that an online Trello board would be used to keep track of the needed tasks. It was also decided early on that GitHub would be the primary version control tool used in the project, due to its familiarity and potential integration with continuous integration tools. In order to fully explore the potential of using an agile development methodology, various continuous integration tools were researched. These included: JetBrains's TeamCity~\cite{teamcity_documentation_ref}, TravisCI~\cite{travis_documentation_ref}, and Jenkins~\cite{jenkins_documentation_ref}. Each CI tool has its strengths, with TravisCI standing out as the most lightweight and easily integrated. TeamCity is developed by JetBrains, several of their products were also considered/used for the project so familiarity would be an advantage. Lastly, Jenkins appeared to be the most widely used tool and therefore would have plenty of documentary and online tutorials. Finally, in order to potentially support any CI tools, the containerization tool 'Docker'~\cite{docker_documentation_ref} was researched for use in the API's development.

\subsubsection{Deployment Options}
Deployment of the Android app itself is made fairly straightforward by Android Studio's build options. Allowing for APK signing and Google Play Store support. However, with regards to the REST API and the Web Application, some research was required to decide on the most appropriate deployment solution. The following solutions were researched and considered as options: Heroku~\cite{heroku_documentation_ref}, Amazon Web Services (AWS)~\cite{aws_documentation_ref}, and self-hosting using Nginx~\cite{nginx_documentation_ref}. Each of these solutions had its advantages, deploying via Heroku would be made simple due to its in-built Docker support. Using AWS would allow for very fine grain control over server size, resources, and traffic management; it would also make supporting SSL encryption trivial. Lastly, a custom hosting solution using Nginx would be the simplest and easiest to manage, due to pre-existing server setups. However, this solution could have some security implications.

\subsection{Functionality Research}
\subsubsection{Related Products}
A major part of the functionality research required for this project was to investigate applications already on the market that are targetted towards Taxi booking creation and management. This research would go on to help identify the key functionalities required within the platform and the most effective way to implement them. Having already decided on a name, rough purpose, and short description. Researching similar products on the market is regarded as the next key step in developing an app idea.

The first and perhaps the most prominent product to be investigated was 'Uber'~\cite{uber_documentation_ref}. Uber's mobile app is designed to manage and delegate bookings for registered Uber drivers and not self-contained Taxi companies. However, the interaction and flow of the booking process between the driver and the customer served as a major influence when coming up with the concept for this project. Together with in-app messaging to allow easy communication between customers and drivers, Uber's use of GPS  is the ultimate goal for booking creation and tracking. However, it was clear from early on that these well-polished features fell outside of the scope of this project.

Having investigated a commercial solution that did not target Taxi companies directly, the research required a more applicable product. 'My Taxi'~\cite{mytaxi_documentation_ref} is a cross-platform, mobile application that allows customers to book, track and pay for their taxi. The app is incredibly well polished and maintained with an intuitive sign-up flow and booking creation process. The app is supported in many major European cities, including Brighton, Edinburgh, London, Manchester, Nottingham, Oxford, Reading, Derby, and Leicester. In addition to their mobile app, they also have a web client to support taxi business administrators.

Lastly, a primarily web-based service, 'minicabit'~\cite{minicabit_documentation_ref} was investigated. Minicabit is a UK based service, that allows users to retrieve taxi booking quotes, it is also possible to book a taxi based on the quotes received. The website's user interface was very friendly and intuitive. The look and feel of the quoting system were very similar to other websites within the travel industry. Although this service provides support for booking taxis, it appeared to have minimal support for any booking management or tracking.

\section{Analysis}
Taking into account the problem and what you learned from the background work, what was your analysis of the problem? How did your analysis help to decompose the problem into the main tasks that you would undertake? Were there alternative approaches? Why did you choose one approach compared to the alternatives? 

There should be a clear statement of the objectives of the work, which you will evaluate at the end of the work. 

In most cases, the agreed objectives or requirements will be the result of a compromise between what would ideally have been produced and what was determined to be possible in the time available. A discussion of the process of arriving at the final list is usually appropriate.

As mentioned in the lectures, think about possible security issues for the project topic. Whilst these might not be relevant for all projects, do consider if there are relevant for your project. Where there are relevant security issues, discuss how they will this affect the work that you are doing. Carry forward this discussion into relevant areas for design, implementation and testing.

\section{Process}
Having narrowed down the options for development methodology to those discussed in Section~\ref{methodology_research_ref} and researched each option it was decided that an adapted version of Extreme Programming would be used for the project. 

Given the restrictions that a plan-based approach such as SDLC  would have on the project, with specific regard to the requirements it was decided the approach had to be agile. Due to the relatively small scale and timeframe of the project, it was also thought that it would be very beneficial to focus on high quality, working software over the documentation required by SDLC.

Feature Driven Development was another agile approach that was considered. Although with adaptations, it could have been very well fitted for a single person project, it was apparent that FDD was intended for use in a team-based project. This is seen in its emphasis on roles. Therefore, it was clear that XP was the most appropriate agile methodology for the project.

XP was selected in the hope that its use would help mitigate the increased risk associated with a project where there is a lack of experience and a lot of learning to do with the technologies used. Due to this increased risk, it was believed that creating a static requirement list would prove difficult and likely be very flawed. Therefore, given that XP is an Agile Approach and is intended to support changing requirements it fit perfectly.

\subsection{Practices}
The following practices are all considered primary practices within Extreme Programming~\cite[Ch.~7]{xp_explained_ref}. They have been selected due to their relevance to the project. The following inapplicable practices have been omitted: Sit Together, Whole Team, Informative Workspace, Pair Programming, Test First. These practices were aspects of XP targetted towards team-based projects and larger workspaces.

\subsubsection{Energized Work}
Although mainly focused on software development teams to ensure a healthy workplace and work/life balance, this practice also suits individual projects very well. By following this practice, work is undertaken at the right time and location for the right length of time, without burning out. This requires that steps be taken to ensure a focused state can be entered to complete work without distractions. 

\subsubsection{Stories}
Stories are a key practice in most agile methodologies, in this project user stories were written for each desired functionality. Each story was labeled as either 'essential' or 'nice to have', this ensured that work was prioritized correctly and essential aspects of the system were built in a timely way. Stories were written on physical, coloured cards and placed on a corkboard in the main work area of the project. They also existed electronically on a Trello~\cite{ref_trello} board, this allowed progress to be shared with the project supervisor and allowed work to be completed away from the main work station. There was also be a static document created with each high-level story written formally, this can be found in the Appendices.

\subsubsection{Weekly Cycle}
Weekly Cycles are synonymous with iterations in other agile methodologies. In this project weekly cycles ran from Saturday-Friday, meaning each cycle began on a Saturday and ended on a Friday. The first day of the cycle mainly consisted of planning and choosing which stories to tackle; there was also an overall reflection and a look at the project's current progress. The goal was that by the end of the cycle all stories had been realized and are now implemented, integrated and tested features within the system. The final day of the cycle involved writing an entry into the project's weekly blog~\cite{blog_ref} reflecting on the week's work and documenting the goals for the next week. By using a weekly cycle, software was constantly being produced, allowing for a regular opportunity to analyze and get feedback.

\subsubsection{Quarterly Cycle}
Quarterly Cycles are synonymous with releases. Given the scale of this project (roughly 12 weeks), a quarterly cycle consisted of 3 weekly cycles. This meant that the first quarterly cycle passed just in time for the mid-project demonstration, thus ensuring there was at least a partially working system to be delivered. At the beginning of each quarterly cycle, a plan was drafted for which stories should be completed in that cycle. The quarterly cycle plan was re-visited briefly at the beginning of each weekly cycle. 

\subsubsection{Slack}
The purpose of slack is to add low priority or non-essential stories to weekly and quarterly cycles. This allowed tasks or stories to be discarded if time became an issue, thus accounting for inaccurate estimates.

\subsubsection{Ten-Minute Build}
The 10-minute build practice is intended to enforce a quick and easy build process, if a build process is long and arduous it is less likely to be done often. Therefore an easy, automatic build process ensured that builds were done frequently, allowing for more feedback and less time between errors.

\subsubsection{Continuous Integration}
Continuous Integration supports the idea of a fast build process. By immediately testing and integrating code systems into the overall system, integration issues were caught much sooner and with less consequence. Continuous Integration also encouraged and enforced frequent and reliable automatic testing.

\subsection{Incremental Design / Refactoring}
Incremental Design suggests that some spike work be done up front to understand how much effort is required and any issues that might arise. This approach reduced risk and allowed for a better estimation for a given story. This practice allowed for informed design decisions to be made when necessary and be made with the most current information available. The practice of incremental design also calls for the use of frequent refactoring to ensure correct design.


\chapter{Background \& Objectives}

\section{Background}
The aim of this project was to create a platform that serves as an intermediary between local taxi companies and their customers. The platform supports three types of users: Company Admin, Driver and Customer. It consists of two user-facing applications: An android app - intended to be usable by Drivers and Customers, and a mobile-friendly web application - intended to be usable by Company Admins. Both applications are served by a single REST API.

Currently, it is intended that a single instance of the platform is used by many taxi companies, each with their own Company Admins and Drivers. The companies would then use the platform as a service in order to support their internal booking mechanisms. However, it can be adapted to be used by a single Company as their sole booking management mechanism. This makes the platform very flexible, allowing for varying use cases.

The primary motivation for this project was to streamline the process of making taxi bookings in small, local areas. With the hope that a fully mobile, digital solution would lead to a better experience for both the companies and their customers. For example, being able to view a history of all bookings could be extremely helpful for cases of lost property, criminal damage, etc. In addition to this, by viewing the live status of their booking, and communicating with their driver via notes, customers can make sure they are present for their booking at the correct time, hopefully resulting in fewer wasted Taxis.

\subsection{Background Research}
In order to successfully execute the project, research had to be done into various aspects of the app's development. This includes methodology, technologies, and deployment options.

\subsubsection{Methodology}
Software Development Methodology is a key part of any large project. The effect of the methodology on the product, along with a project's ability to adapt to the methodology should always be considered when making a selection. With this in mind, several options were researched for the project.

The first methodology researched was the Waterfall Model, or 'SDLC'~\cite{sdlc_ref}. Having already worked on a project using the Waterfall Model, there was less of a focus on researching the methodology but rather to consider its applicability in this project. As the Waterfall Model is a plan-driven approach it would require a lot of upfront documentation and decision making with regards to requirements, thus potentially making it rather inflexible. Given that this project also involved a significant learning curve with regards to the technologies used, it would perhaps be tricky to accurately gauge the ability to implement various functionalities early on.

The next methodology researched was Feature Driven Development, or 'FDD'~\cite{fdd_practical_guide_ref}. FDD is an agile methodology created by Jeff Luca, it is an iterative approach with an emphasis on the timely and successful delivery of features. It is broken down into 5 key processes: developing an overall model, building the feature list, planning by feature, designing by feature, and building by feature. It is clear from these processes that the project's development would be done on a 'per-feature' basis, comparable to stories in other agile methodologies. At first impressions, this methodology seemed much more appropriate for the project than a plan based approach.

Extreme Programming or 'XP'~\cite{xp_explained_ref, xp_agilealliance_ref}, was the final methodology to be researched. It was one of the recommended methodologies provided for the project. XP is described as being ideal in projects with dynamically changing requirements, risks from fixed time projects using new technology, and when using technologies that allow for automated tests~\cite{xp_agilealliance_ref}. The methodology is often identified by its values, which give a great indication to the mission of XP. Reading literature written by one of XP's creators provided a great insight into the application of XP and its key advantages over other approaches.

\subsubsection{Technologies}
Having only experienced Android app development with a local, offline backend; it was essential to the project's success that research was done to explore the tools and technologies available to support a networked mobile app. This research was required for each aspect of the project, including its deployment.

The first and arguably most significant area to research was the API that would support the app(s). It was clear from very early on that there would likely be at least two apps within the platform to consume the API (web app and mobile app).  Therefore, an API would need to be developed and a language/framework had to be selected to develop such an API. The researched options were: ASP.NET~\cite{dotnet_documentation_ref}, Rails 5~\cite{rails_documentation_ref}, Node.js \& Express.js~\cite{nodejs_documentation_ref, expressjs_documentation_ref} and Flask (Flask-RESTful)~\cite{flask_documentation_ref}. All of the researched options had fairly similar learning curves (due to the technology they are built on and past experiences), each option was also perfectly fit for purpose to create a REST API  to serve a mobile application.

The next technology to research was the database management system (DBMS) that would be used by the REST API for data persistence. The selected DBMS would ideally be able to interface easily with the framework used to create the API itself. The options researched were: PostgreSQL~\cite{postgres_documentation_ref}, MySQL~\cite{mysql_documentation_ref}, and MongoDB~\cite{mongodb_documentation_ref}. The first two options were both traditional relational database management systems, whereas the final option is a NoSQL document-oriented system.

In order to successfully consume the REST API within the Android application, a HTTP Client library had to be chosen. During this selection, two complementary technologies were researched, Retrofit~\cite{retrofit_documentation_ref} and rxJava~\cite{rxjava_documentation_ref}. Retrofit is a HTTP Client library for Java and Android that is primarily used to consume REST APIs, rxJava is an asynchronous programming library with observable streams. This allows requests to be made to the REST API from the mobile application and the responses can be stored in a life-cycle aware Observable object, thus fully supporting asynchronous programming.

It became apparent that a relatively small web app would need to be created as part of the platform to support the Company Administrator's role. Therefore, a front-end web framework to consume the API had to be chosen. The frameworks that were looked into were: Angular~\cite{angular_documentation_ref} and React~\cite{react_documentation_ref}. Although Vue.js~\cite{vue_documentation_ref} was initially considered, it became apparent that React and Angular were the two most prominent options and would be the most beneficial technologies to learn.

Due to previous experience, it was already decided that Android Studio would be the chosen IDE used to develop the Android application. However, there was still a decision to be made about developing the API and Web Application. The standard code editor 'Atom' had been used for previous web projects. However, upon further research JetBrains's 'WebStorm' IDE was discovered. Therefore research was done into both solutions in order to select the most appropriate.

Lastly, project management, deployment, and development tools had to be researched. In terms of project management, it was already decided that an online Trello board would be used to keep track of the needed tasks. It was also decided early on that GitHub would be the primary version control tool used in the project, due to its familiarity and potential integration with continuous integration tools. In order to fully explore the potential of using an agile development methodology, various continuous integration tools were researched. These included: JetBrains's TeamCity~\cite{teamcity_documentation_ref}, TravisCI~\cite{travis_documentation_ref}, and Jenkins~\cite{jenkins_documentation_ref}. Each CI tool has its strengths, with TravisCI standing out as the most lightweight and easily integrated. TeamCity is developed by JetBrains, several of their products were also considered/used for the project so familiarity would be an advantage. Lastly, Jenkins appeared to be the most widely used tool and therefore would have plenty of documentary and online tutorials. Finally, in order to potentially support any CI tools, the containerization tool 'Docker'~\cite{docker_documentation_ref} was researched for use in the API's development.

\subsubsection{Deployment Options}
Deployment of the Android app itself is made fairly straightforward by Android Studio's build options. Allowing for APK signing and Google Play Store support. However, with regards to the REST API and the Web Application, some research was required to decide on the most appropriate deployment solution. The following solutions were researched and considered as options: Heroku~\cite{heroku_documentation_ref}, Amazon Web Services (AWS)~\cite{aws_documentation_ref}, and self-hosting using Nginx~\cite{nginx_documentation_ref}. Each of these solutions had its advantages, deploying via Heroku would be made simple due to its in-built Docker support. Using AWS would allow for very fine grain control over server size, resources, and traffic management; it would also make supporting SSL encryption trivial. Lastly, a custom hosting solution using Nginx would be the simplest and easiest to manage, due to pre-existing server setups. However, this solution could have some security implications.

\subsection{Functionality Research}
\subsubsection{Related Products}
A major part of the functionality research required for this project was to investigate applications already on the market that are targetted towards Taxi booking creation and management. This research would go on to help identify the key functionalities required within the platform and the most effective way to implement them. Having already decided on a name, rough purpose, and short description. Researching similar products on the market is regarded as the next key step in developing an app idea.

The first and perhaps the most prominent product to be investigated was 'Uber'~\cite{uber_documentation_ref}. Uber's mobile app is designed to manage and delegate bookings for registered Uber drivers and not self-contained Taxi companies. However, the interaction and flow of the booking process between the driver and the customer served as a major influence when coming up with the concept for this project. Together with in-app messaging to allow easy communication between customers and drivers, Uber's use of GPS  is the ultimate goal for booking creation and tracking. However, it was clear from early on that these well-polished features fell outside of the scope of this project.

Having investigated a commercial solution that did not target Taxi companies directly, the research required a more applicable product. 'My Taxi'~\cite{mytaxi_documentation_ref} is a cross-platform, mobile application that allows customers to book, track and pay for their taxi. The app is incredibly well polished and maintained with an intuitive sign-up flow and booking creation process. The app is supported in many major European cities, including Brighton, Edinburgh, London, Manchester, Nottingham, Oxford, Reading, Derby, and Leicester. In addition to their mobile app, they also have a web client to support taxi business administrators.

Lastly, a primarily web-based service, 'minicabit'~\cite{minicabit_documentation_ref} was investigated. Minicabit is a UK based service, that allows users to retrieve taxi booking quotes, it is also possible to book a taxi based on the quotes received. The website's user interface was very friendly and intuitive. The look and feel of the quoting system were very similar to other websites within the travel industry. Although this service provides support for booking taxis, it appeared to have minimal support for any booking management or tracking.

\section{Analysis}
Taking into account the problem and what you learned from the background work, what was your analysis of the problem? How did your analysis help to decompose the problem into the main tasks that you would undertake? Were there alternative approaches? Why did you choose one approach compared to the alternatives? 

There should be a clear statement of the objectives of the work, which you will evaluate at the end of the work. 

In most cases, the agreed objectives or requirements will be the result of a compromise between what would ideally have been produced and what was determined to be possible in the time available. A discussion of the process of arriving at the final list is usually appropriate.

As mentioned in the lectures, think about possible security issues for the project topic. Whilst these might not be relevant for all projects, do consider if there are relevant for your project. Where there are relevant security issues, discuss how they will this affect the work that you are doing. Carry forward this discussion into relevant areas for design, implementation and testing.

\section{Process}
You need to describe briefly the life cycle model or research method that you used. You do not need to write about all of the different process models that you are aware of. Focus on the process model that you have used. It is possible that you needed to adapt an existing process model to suit your project; clearly identify what you used and how you adapted it for your needs.

